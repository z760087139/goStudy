package main

import (
	"fmt"
	"study/class2/code3/pk1"
)

// 关于包的调用
// 1.11 版本后, go 语言推出了官方的模块管理工具
// 在study 目录下有一个go.mod 的文件，是由go mod 命令生成（完整命令为go mod init study）
// go module 可以管理整个项目中需要调用的库、下载地址、库的版本信息等
// 在没有go module 之前，所有的go语言项目都应该放在gopath目录下
// 创建了go.mod 文件后，会以go.mod 目录为项目根目录

// 引用不同的包可以按照import pk1中的路径形式写

func f1() {
	pk1.MyPrint()
	// pk.printString() 无法调用f2.go的函数
}

// 关于作用域

// 定义来自GO语言圣经
// 句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。
// 句法块内部声明的名字是无法被外部块访问的。
// 这个块决定了内部声明的名字的作用域范围。
// 我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。
// 对全局的源代码来说，存在一个整体的词法块，称为全局词法块；
// 对于每个包，每个for、if和switch语句，也都对应词法块；每个switch或select的分支也有独立的语法块；
// 当然也包括显式书写的词法块（花括弧包含的语句）。

// 声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。
// 任何在在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。
// 对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。
// 还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。

// 简单概括
// GO语言的for,if,switch等语句块内部定义的变量，只能在这些语句块内部使用。除此以外与其他语言基本相同
// 全局变量、函数作用域等

// for 作用域例子
func f2() {
	x := 10
	for i := 0; i < 3; i++ {
		y := x + i
		fmt.Println(y)
	}
	// fmt.Println(y) // 无法执行，未定义y
}

// 全局变量例子
var xx int = 10

func f3() {
	// 调用全局变量
	fmt.Println("value:", xx, "pointer:", &xx)
	// 创建同名的变量
	xx := 100
	fmt.Println("value:", xx, "pointer:", &xx)
	// 打印全局变量
	f4()
}

// 打印全局变量
func f4() {
	fmt.Println("value:", xx, "pointer:", &xx)
}

func main() {
	f3()
}
